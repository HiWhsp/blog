# SSR

## SPA

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## **Vue SSR 的实现原理**

> - _app.js_ 作为客户端与服务端的公用入口，导出 _Vue_ 根实例，供客户端 _entry_ 与服务端 _entry_ 使用。客户端 _entry_ 主要作用挂载到 _DOM_ 上，服务端 _entry_ 除了创建和返回实例，还需要进行路由匹配与数据预获取。
> - _webpack_ 为客服端打包一个 _ClientBundle_，为服务端打包一个 _ServerBundle_。
> - 服务器接收请求时，会根据 _url_，加载相应组件，获取和解析异步数据，创建一个读取 _Server Bundle_ 的 _BundleRenderer_，然后生成 _html_ 发送给客户端。
> - 客户端混合，客户端收到从服务端传来的 _DOM_ 与自己的生成的 _DOM_ 进行对比，把不相同的 _DOM_ 激活，使其可以能够响应后续变化，这个过程称为客户端激活（也就是转换为单页应用）。为确保混合成功，客户 端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 _store_ 里，这样，在客户端挂载到 _DOM_ 之前，可以直接从 _store_ 里取数据。首屏的动态数据通过 _window.**INITIAL_STATE**_ 发送到客户端
> - _VueSSR_ 的原理，主要就是通过 _vue-server-renderer_ 把 _Vue_ 的组件输出成一个完整 _HTML_，输出到客户端，到达客户端后重新展开为一个单页应用。
